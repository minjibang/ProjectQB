<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:security="http://www.springframework.org/schema/security"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
  http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd">

	<!-- 1단계:인증과 권한 기본 설정(in-memory 방식(DB사용 X)으로 사용자 및 권한 설정) auto-config="true" 
		-> 로그인 처리부터 로그아웃 까지 자동화 intercept-url ->이 url로 요청이 오면 가로채서 ㅊㅓ리 -->
	<!-- <security:http auto-config="true"> <security:intercept-url pattern="/customer/noticeDetail.htm" 
		access="hasRole('ROLE_USER')"/> <security:intercept-url pattern="/customer/noticeReg.htm" 
		access="hasRole('ROLE_ADMIN')"/> </security:http> <security:authentication-manager> 
		<security:authentication-provider> 메모리에올라가는 사용자를 만들수있따? <security:user-service> 
		한명의 사용자는 여러권한을 가질 수 있따 <security:user name="minji" password="1004" authorities="ROLE_USER"/> 
		<security:user name="admin" password="1004" authorities="ROLE_USER,ROLE_ADMIN"/> 
		</security:user-service> </security:authentication-provider> </security:authentication-manager> -->

	<!-- 2단계: 커스터마이징(로그인페이지를 내가만든페이지로,,) 요청:/login 컨트롤러 요청 자동화 처리: 입력한 Id, pw받기 
		-> 인증검사 -> in-memory안에 있는지->권한 검사->통과하면 요청페이지로 /logout 컨트롤러 요청도 자동화 처리 됨 
		: session소멸하기...(현재는 처리하고 있지 않음) 개발자가 직접 login과 logout을 처리 하겠다. <security:form-login 
		login-page="/joinus/login.htm" authentication-failure-url="/joinus/login.htm?error"/> 
		로그인시 해당 url로 로그인 페이지 요청 로그인 실패 시 메시지를 가지고 return <security:logout logout-success-url="/index.htm"/> 
		->로그아웃 성공시 해당 url 로 이동 -->
	<!-- <security:http auto-config="true"> <security:csrf disabled="true"/> 
		<security:form-login login-page="/joinus/login.htm" authentication-failure-url="/joinus/login.htm?error"/> 
		인증이 되지 않으면 이 url 로 로그인페이지를 요청하겠따 <security:logout logout-success-url="/index.htm"/> 
		<security:intercept-url pattern="/customer/noticeDetail.htm" access="hasRole('ROLE_USER')" 
		/> <security:intercept-url pattern="/customer/noticeReg.htm" access="hasRole('ROLE_ADMIN')" 
		/> </security:http> <security:authentication-manager> <security:authentication-provider> 
		<security:user-service> <security:user name="minji" password="1004" authorities="ROLE_USER" 
		/> <security:user name="admin" password="1004" authorities="ROLE_USER,ROLE_ADMIN" 
		/> </security:user-service> </security:authentication-provider> </security:authentication-manager> -->
	<!-- 3단계 -->

	<security:http auto-config="true">
		<security:csrf disabled="true" />
		<security:form-login
			login-page="/index.htm"
			authentication-failure-url="/index.htm?error"/>
			
		<security:logout logout-success-url="/index.htm" />
		<!--  <security:intercept-url
			pattern="/login.htm" access="hasRole('ROLE_USER')" /> -->
		  <!-- <security:intercept-url pattern="/login.htm"	access="hasRole('ROLE_USER')" />  
			 -->
	</security:http>
	<!-- 로그인 완료후 처리할 handler -->
	



	<security:authentication-manager>
		<security:authentication-provider>
			<security:jdbc-user-service
				data-source-ref="driverManagerDataSource"
				users-by-username-query="SELECT USERID, pwd AS PASSWORD, 1 enabled FROM chatusers where userid=?"
				authorities-by-username-query="select c.USERID , r.ROLE_NAME  
           									  from chatusers c join role r 
          									 on c.userid = r.userid 
          									 where c.userid=?" />
			<!-- <security:password-encoder
				ref="bCryptPasswordEncoder" /> -->
		</security:authentication-provider>
	</security:authentication-manager>

</beans>
